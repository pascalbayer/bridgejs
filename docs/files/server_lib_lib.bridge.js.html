<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>server/lib/lib.bridge.js - bridgejs</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/prettify.css"/>
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
    <script type="text/javascript" src="../assets/js/prettify.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="bridgejs"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.5</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Bridge.html">Bridge</a></li>
            
                <li><a href="../classes/Bridge.Accounts.html">Bridge.Accounts</a></li>
            
                <li><a href="../classes/Bridge.Collection.html">Bridge.Collection</a></li>
            
                <li><a href="../classes/Bridge.Error.html">Bridge.Error</a></li>
            
                <li><a href="../classes/Bridge.Socket.html">Bridge.Socket</a></li>
            
                <li><a href="../classes/Cursor.html">Cursor</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: server/lib/lib.bridge.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
 * bridgejs
 * http://bridgejs.com/
 *
 * Copyright (c) 2013 Pascal Bayer
 * Licensed under the MIT license.
 * https://github.com/pascalbayer/bridgejs/blob/master/LICENSE
 */

var Bridge = typeof global != &#x27;undefined&#x27; ? module.exports : {};
var underscore = typeof global != &#x27;undefined&#x27; ? require(&#x27;underscore&#x27;) : window._;
var database = typeof global != &#x27;undefined&#x27; ? require(&#x27;mongojs&#x27;) : {};
var socketio = typeof global != &#x27;undefined&#x27; ? require(&#x27;socket.io&#x27;) : window.io;
var fs = typeof global != &#x27;undefined&#x27; ? require(&#x27;fs&#x27;) : {};

/**
 * Bridge provides all framework components on a client as well as a server
 *
 * @class Bridge
 * @type {Bridge}
 */
(function (Bridge, underscore, database, socketio, fs) {
    var db = database;
    var socket = socketio;
    var onEvents = [];
    var emitEvents = [];
    var publishedCollections = {};
    var pendingSubscriptions = {
        counter: 0,
        callbacks: []
    };
    var _ = underscore;

    /**
     * Stores the global configuration settings
     *
     * @property Settings
     * @type {Object}
     * @example
     * Available setting:
     *
     *      Bridge.Settings = {
     *          server: &#x27;127.0.0.1:80&#x27;,     // server to connect to
     *          database: &#x27;test&#x27;,           // database to connect to
     *          language: &#x27;de-de&#x27;           // set a language for localized messages
     *      }
     */
    Bridge.Settings = {
        server: null,
        database: null,
        language: &#x27;en-en&#x27;
    };
    /**
     * Indicates whether the script is running on a server (&#x60;true&#x60;) or a client (&#x60;false&#x60;)
     *
     * @property isServer
     * @type Boolean
     * @example
     * For running code only on server:
     *
     *      if (Bridge.isServer) {
     *          // code is only executed on the server
     *      }
     */
    Bridge.isServer = (function () {
        return (typeof global != &#x27;undefined&#x27;);
    }());
    /**
     * Indicates whether the script is running on a client (&#x60;true&#x60;) or a server (&#x60;false&#x60;)
     *
     * @property isClient
     * @type Boolean
     * @example
     * For running code only on client:
     *
     *      if (Bridge.isClient) {
     *          // code is only executed on the client
     *      }
     */
    Bridge.isClient = !Bridge.isServer;
    /**
     * &lt;b&gt;USAGE: Anywhere&lt;/b&gt;
     *
     * @method ready
     * @param callback {Function}
     * @example
     * Register a ready callback
     *
     *      Bridge.ready(function () {
     *          // Code to execute when client/server is ready
     *      });
     */
    Bridge.ready = function (callback) {
        if (Bridge.isServer) {
            //TODO: implement server ready event
        }
        else {
            if (typeof callback == &#x27;function&#x27;) {
                document.addEventListener(&#x27;DOMContentLoaded&#x27;, callback, false);
            }
        }
    };
    /**
     * Connect to a bridge instance
     *
     * @method connect
     * @example
     * Connect to an instance
     *
     *      Bridge.connect();
     */
    Bridge.connect = function () {
        //TODO: return true after successful connection
        if (Bridge.isServer) {
            db = db(Bridge.Settings.database);
            socket = socket.listen(Bridge.Settings.server).sockets;
            socket.on(&#x27;connection&#x27;, function (iosocket) {
                for (var event in onEvents) {
                    iosocket.on(onEvents[event].name, onEvents[event].callback);
                }
                for (var event in emitEvents) {
                    iosocket.emit(emitEvents[event].name, emitEvents[event].data);
                }
            });

            var path = &#x27;/bridgejs&#x27;;
            var listeners = Bridge.Settings.server.listeners(&#x27;request&#x27;).slice(0);
            Bridge.Settings.server.removeAllListeners(&#x27;request&#x27;);

            Bridge.Settings.server.on(&#x27;request&#x27;, function (request, response) {
                if (path == request.url.substr(0, path.length)) {
                    if (request.url == &#x27;/bridgejs/bridge.js&#x27;) {
                        fs.readFile(__dirname + &#x27;/server/lib.bridge.js&#x27;, function (error, content) {
                            if (!error) {
                                response.writeHead(200, {
                                    &#x27;Content-Type&#x27;: &#x27;text/javascript&#x27;
                                });
                                response.end(content, &#x27;utf-8&#x27;);
                            }
                        });
                    }
                    else {
                        response.end(&#x27;Welcome to bridge.js.&#x27;);
                    }
                } else {
                    for (var i = 0, l = listeners.length; i &lt; l; i++) {
                        listeners[i].call(Bridge.Settings.server, request, response);
                    }
                }
            });
        }
        else {
            socket = socket.connect(Bridge.Settings.server);
        }
    };
    /**
     * Sort an array
     *
     * @method sort
     * @param array
     * @param [descending]
     * @param [property]
     * @example
     * Sort the array passed as parameter, optionally pass in the sort order asc/desc and/or a field to sort by if the
     * array contains objects with subfields/subproperties
     *
     *      // sort array descending
     *      var array = Bridge.sort([1, 2, 5, 3, 9, 6, 4], true);
     *
     *      // sort array by property
     *      var array = Bridge.sort([{name: &#x27;Fabienne&#x27;}, {name: &#x27;Svenja&#x27;}, {name: &#x27;Isabel&#x27;}], &#x27;name&#x27;);
     *
     *      // sort array by subproperty using the &#x60;.subfield&#x60; convention, subfield must exist otherwise the function
     *      // will throw an error
     *      var array = Bridge.sort([
     *          {name: {prename: &#x27;Fabienne&#x27;}},
     *          {name: {prename: &#x27;Svenja&#x27;}},
     *          {name: {prename: &#x27;Isabel&#x27;}}], &#x27;name.prename&#x27;);
     *
     *      // sort array by field and descending
     *      var array = Bridge.sort([{name: &#x27;Fabienne&#x27;}, {name: &#x27;Svenja&#x27;}, {name: &#x27;Isabel&#x27;}], true, &#x27;name&#x27;);
     */
    Bridge.sort = function (array, descending, property) {
        var sort = (function () {
            var order = (descending == true) ? -1 : 1;
            property = typeof descending == &#x27;string&#x27; ? descending : property;
            var parts = property ? property.split(&#x27;.&#x27;) : null;

            return function (a, b) {
                if (parts) {
                    parts.forEach(function (item) {
                        a = a[item];
                    });
                    parts.forEach(function (item) {
                        b = b[item];
                    });
                }

                var result = (a &lt; b) ? -1 : (a &gt; b) ? 1 : 0;
                return result * order;
            }
        }());

        array.sort(sort);

        return array;
    };
    /**
     * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Anywhere&lt;/div&gt;
     * Generates a unique id in RFC 4122 v4 format
     *
     * @method uuid
     * @return {String} uuid
     * @example
     * Generate a new uuid
     *
     *      Bridge.uuid(); // Returns a string like &#x27;c3d4ef3c-54ea-47fc-c874-66952365d789&#x27;
     */
    Bridge.uuid = function () {
        var date = new Date().getTime();
        return &#x27;XXXXXXXX-XXXX-4XXX-YXXX-XXXXXXXXXXXX&#x27;.replace(/[XY]/g, function (character) {
            var random = (date + Math.random() * 16) % 16 | 0;
            date = Math.floor(date / 16);
            return (character == &#x27;X&#x27; ? random : (random &amp; 0x7 | 0x8)).toString(16);
        });
    };

    // Functionality only available on the server
    if (Bridge.isServer) {
        /**
         * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Server&lt;/div&gt;
         * Publish a collection or parts of on the server side
         *
         * @method publish
         * @param name
         * @param callback
         * @example
         * Publish a collection on the server. The callback function should always return a Cursor to the collection
         * items you want to publish.
         *
         *      Bridge.publish(&#x27;allposts&#x27;, function([optionalArgumentsArray]) {
         *          var Posts = Bridge.Collection(&#x27;Posts&#x27;);
         *          return Posts.find({username: &#x27;My name&#x27;}).sort({date: 1}).limit(30);
         *      });
         */
        Bridge.publish = function (name, callback) {
            var cursor = callback();

            if (!publishedCollections[cursor.collection]) {
                publishedCollections[cursor.collection] = {};
            }
            else {
                if (!publishedCollections[cursor.collection][name]) {
                    publishedCollections[cursor.collection][name] = {};
                }
            }
            publishedCollections[cursor.collection][name] = {
                callback: callback,
                subscribers: []
            }
        };
    }
    // Functionality only available on the client
    else {
        /**
         * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Client&lt;/div&gt;
         * Subscribe a collection on the client
         *
         * @method subscribe
         * @param name
         * @param [args] {Array} Provide an array of optional arguments that are passed to the server&#x27;s publish function
         * @param [callback] {Function} Provide an optional callback that is called when all data is received from the
         * server and cached locally
         * @example
         * Subscribe to a collection that is published on the server
         *
         *      Bridge.subscribe(&#x27;allposts&#x27;, [&#x27;argument1&#x27;, &#x27;argument2&#x27;], function (Error) {
         *          if (Error) {
         *              Bridge.Error(Error.message);
         *          }
         *          else {
         *              var Posts = Bridge.Collection(&#x27;Posts&#x27;);
         *          }
         *      });
         */
        Bridge.subscribe = function (name, args, callback) {
            Bridge.Socket.emit(&#x27;subscribe&#x27;, {
                name: name,
                args: args || null
            });
            pendingSubscriptions.counter++;
            // TODO: Add counter to avoid that toArray/bind is called while a subscription is pending for the collection
        };

        Bridge.subscriptionsCompleted = function (callback) {
            pendingSubscriptions.callbacks.push(callback);
        };
    }
    /**
     * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Anywhere&lt;/div&gt;
     * The Cursor class is not directly accessible but it is returned whenever you call the &#x60;.find()&#x60; method of a
     * collection. A Cursor object provides standard methods to filter your result set.
     *
     * @class Cursor
     * @param collection {String}
     * @param selector
     * @param fields {Object}
     * @param options {Object}
     * @return {Cursor}
     * @constructor
     */
    var Cursor = function (collection, selector, fields, options) {
        var Cursor = function () {
            this.collection = collection;
            this.selector = selector;
            this.fields = fields;
            this.options = !options ? {} : options;

            this.sortValue = null;
            this.limitValue = null;
        };
        /**
         * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Anywhere&lt;/div&gt;
         * Sort the result set
         *
         * @method sort
         * @param sortValue {Object}
         * @return {Cursor}
         * @example
         * Sort your results. Provide field to sort and 1 for ascending or -1 for descending.
         *
         *      var Posts = new Bridge.Collection(&#x27;Posts&#x27;);
         *      Posts.find().sort({date: 1});
         */
        Cursor.prototype.sort = function (sortValue) {
            this.sortValue = sortValue;

            return this;
        };
        /**
         * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Anywhere&lt;/div&gt;
         * Limit the result set
         *
         * @method limit
         * @param limitValue {Integer}
         * @return {Cursor}
         * @example
         * Limit your results. Provide the number of results you want to retrieve. You will get back the first results
         * found in the database within the limit. Normally the results are stored in the database based on the order
         * they where inserted in.
         *
         *      var Posts = new Bridge.Collection(&#x27;Posts&#x27;);
         *      Posts.find().limit(5);
         */
        Cursor.prototype.limit = function (limitValue) {
            this.limitValue = limitValue;

            return this;
        };
        /**
         * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Anywhere&lt;/div&gt;
         * Create a complete result set
         *
         * @method toArray
         * @param callback {Function}
         * @return {Cursor}
         * @example
         * Create an array of all results matching the current cursor options. &lt;span class=&quot;important-info&quot;&gt;Warning, the
         * array is completely mapped on the servers main memory depending on the number of items within the collection
         * that could cause a lot of memory usage. If you do not need to use the &#x60;toArray&#x60; function, you could use
         * &#x60;stream&#x60; instead to save memory&lt;/span&gt;
         *
         *      var Posts = new Bridge.Collection(&#x27;Posts&#x27;);
         *      Posts.find().toArray(function (items) {
         *          console.log(items);
         *      });
         */
        Cursor.prototype.toArray = function (callback) {
            if (Bridge.isServer) {
                db.collection(this.collection).find(this.selector, this.fields).sort(this.sortValue).limit(this.limitValue, function (err, items) {
                    callback(items);
                });
            }
            else {
                var result = selectElementsFromCollection(this.collection, this.selector);

                if (_.isObject(this.fields) &amp;&amp; !_.isArray(this.fields)) {
                    var fields = this.fields;

                    result = _.map(result, function (item) {
                        var obj = {};
                        for (var field in fields) {
                            if (fields[field]) {
                                if (item.hasOwnProperty(field)) {
                                    obj[field] = item[field];
                                }
                            }
                        }

                        obj._id = item._id;

                        return obj;
                    });
                }

                if (this.sortValue) {
                    var keys = {
                        key: Object.keys(this.sortValue)[0],
                        value: this.sortValue[Object.keys(this.sortValue)[0]]
                    };

                    result = Bridge.sort(result, (keys.value == -1), keys.key);
                }

                if (this.limitValue) {
                    var tempArray = [];

                    for (var i = 0; (i &lt; this.limitValue) &amp;&amp; (i &lt; result.length); i++) {
                        tempArray.push(result[i]);
                    }

                    result = tempArray;
                }

                callback(result);
            }

            return this;
        };

        Cursor.prototype.bind = function (callback) {
            if (!db[this.collection].bindings) {
                db[this.collection].bindings = [];
            }
            db[this.collection].bindings.push({
                cursor: this,
                callback: callback
            })
        };

        return new Cursor;
    };
    /**
     * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Anywhere&lt;/div&gt;
     *
     * @Class Bridge.Collection
     * @param [name] {String} Provide a name for the collection to create a consistent collection that is synchronized with the
     * server. Otherwise the collection is only created for the current client session.
     * @return {Collection}
     * @constructor
     */
    Bridge.Collection = function (name) {
        var rulesset = null;

        var Collection = function () {
            if (Bridge.isClient) {
                if (!db.hasOwnProperty(name)) {
                    db[name] = [];
                }
            }
        };
        Collection.prototype.insert = function (data) {
            data._id = Bridge.uuid();
            if (Bridge.isServer) {
                db.collection(name).insert(data);
            }
            else {
                db[name].push(data);

                Bridge.Socket.emit(&#x27;insert&#x27;, {
                    collection: name,
                    data: data
                });

                for (var binding in db[name].bindings) {
                    db[name].bindings[binding].cursor.toArray(function (items) {
                        db[name].bindings[binding].callback(items);
                    });
                }
            }
        };
        /**
         * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Anywhere&lt;/div&gt;
         *
         * @method find
         * @param [query] {Object}
         * @param [projection] {Object}
         * @return {Cursor}
         * @example
         * Find records in a collection matching the specified query, result contains specified fields
         *
         *      var Posts = new Bridge.Collection(&#x27;Posts&#x27;);
         *      // Find all elements in a collection
         *      Posts.find().toArray(function (items) {
         *          console.log(items);
         *      });
         *      // Find a record in the collection with field &#x60;_id&#x60; matching &#x27;c3d4ef3c-54ea-47fc-c874-66952365d789&#x27;
         *      Posts.find({_id: &#x27;c3d4ef3c-54ea-47fc-c874-66952365d789&#x27;}).toArray(function (items) {
         *          console.log(items);
         *      });
         *      // Find all records in a collection result should only contain field &#x60;post&#x60;
         *      Posts.find(null, []).
         */
        Collection.prototype.find = function find(query, projection) {
            var args = Array.prototype.slice.call(arguments);
            var selector = args[0] || null;
            var fields = args[1] || [];
            return new Cursor(name, selector, fields);
        };
        /**
         * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Anywhere&lt;/div&gt;
         *
         * @method update
         * @param query
         * @param document
         * @param options {Object}
         *      - upsert: {Boolean, default: false}, perform an upsert operation
         *      - multi: {Boolean, default: false}, update all documents matching the selector
         * @param callback {Function}
         * @example
         * Update the first document matched by the selector. $set &amp; $inc are supported
         *
         *      var Posts = new Bridge.Collection(&#x27;Posts&#x27;);
         *      // Update the post message for the document with _id: &#x27;6bcdc8c3-6a41-4325-b439-e8a308ba1638&#x27;
         *      Posts.update({_id: &#x27;6bcdc8c3-6a41-4325-b439-e8a308ba1638&#x27;}, {$set: {post: &#x27;ABCD&#x27;}});
         */
        Collection.prototype.update = function (query, document, options, callback) {
            if (Bridge.isServer) {
                db.collection(name).update(query, document, options, callback);
            }
            else {
                //db.products.update( { item: &quot;book&quot;, qty: { $gt: 5 } }, { $set: { x: 6, y: 15 } }, { multi: true } )
                //db.products.update( { item: &quot;book&quot;, qty: { $gt: 5 } }, { x: 6, y: 15 } ) remove all other fields
                //db.products.update( { item: &quot;book&quot;, qty: { $gt: 5 } }, { $set: { x: 6 }, $inc: { y: 5 } } )
                var results = selectElementsFromCollection(name, query);

                if (results.length &gt; 0) {
                    var tempResults = [{}];

                    var keys = Object.keys(document);

                    // TODO: Add multi support, iterate on results array;
                    for (var key in keys) {
                        switch (keys[key]) {
                            case &#x27;$set&#x27;:
                                var innerKeys = Object.keys(document[keys[key]]);

                                for (var innerKey in innerKeys) {
                                    tempResults[0][innerKeys[innerKey]] = document[keys[key]][innerKeys[innerKey]];
                                }
                                break;
                            case &#x27;$inc&#x27;:
                                var innerKeys = Object.keys(keys[key]);

                                for (var innerKey in innerKeys) {
                                    if (results[0].hasOwnProperty(innerKey)) {
                                        tempResults[0][innerKeys[innerKey]] = results[0][innerKeys[innerKey]] + document[keys[key]][innerKeys[innerKey]];
                                    }
                                }
                                break;
                            default:

                                break;
                        }
                    }

                    var items = db[name];

                    for (var item in items) {
                        if (items[item][&#x27;_id&#x27;] == results[0][&#x27;_id&#x27;]) {
                            tempResults[0][&#x27;_id&#x27;] = results[0][&#x27;_id&#x27;];
                            db[name][item] = tempResults[0];
                        }
                    }

                    for (var binding in db[name].bindings) {
                        db[name].bindings[binding].cursor.toArray(function (items) {
                            db[name].bindings[binding].callback(items);
                        });
                    }

                    Bridge.Socket.emit(&#x27;update&#x27;, {
                        collection: name,
                        query: query,
                        document: document,
                        options: options
                    });
                }
            }
        };
        /**
         *
         * @param query
         */
        Collection.prototype.remove = function (query) {
            if (Bridge.isServer) {
                db.collection(name).remove(query);
            }
            else {
                var bindings = db[name].bindings;

                if (query) {
                    var keys = Object.keys(query);

                    if (keys.length &lt; 1) {
                        db[name] = [];
                    }
                    else {
                        for (var i = 0; i &lt; db[name].length; i++) {
                            var item = db[name][i];

                            // TODO: fix deletion error query {user: &#x27;Chrome&#x27;, post: &#x27;x&#x27;} currently deletes all items matching one of the selectors

                            _.each(keys, function (key) {
                                if (item.hasOwnProperty(key)) {
                                    if (item[key] == query[key]) {
                                        db[name].splice(i--, 1);
                                    }
                                }
                            });
                        }
                    }
                }
                else {
                    db[name] = [];
                }

                db[name].bindings = bindings;

                for (var binding in db[name].bindings) {
                    db[name].bindings[binding].cursor.toArray(function (items) {
                        db[name].bindings[binding].callback(items);
                    });
                }

                Bridge.Socket.emit(&#x27;remove&#x27;, {
                    collection: name,
                    data: query
                });
            }
        };
        if (Bridge.isServer) {
            Collection.prototype.allow = function (rules) {
                rulesset = rules;
            }
        }

        return new Collection;
    };

    Bridge.Route = (function () {
        var add = function (url, callback) {

        };

        return {
            add: function (url, callback) {
                add(url, callback);
            }
        }
    }());

    /**
     * Socket provides functions for creating new web sockets clients/servers by providing functions for Socket.listen,
     * Socket.emit and Socket.on for a socket
     *
     * @class Bridge.Socket
     */
    Bridge.Socket = (function () {
        var on = function (name, callback) {
            if (Bridge.isServer) {
                onEvents.push({name: name, callback: callback});
            }
            else {
                socket.on(name, callback);
            }
        };

        var emit = function (name, data, id) {
            //TODO: Error when user tries to emit without a connection
            if (Bridge.isServer) {
                if (id) {
                    socket.sockets[id].emit(name, data);
                }
                else {
                    emitEvents.push(name, data);
                }
            }
            else {
                socket.emit(name, data);
            }
        };

        var broadcast = function (name, data) {
            for (var iosocket in socket.sockets) {
                socket.sockets[iosocket].emit(name, data);
            }
        };

        var broadcastTo = function (name, data, ids) {
            for (var iosocket in socket.sockets) {
                for (var id in ids) {
                    if (socket.sockets[iosocket].id == ids[id]) {
                        socket.sockets[iosocket].emit(name, data);
                    }
                }
            }
        };

        return {
            /**
             * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Anywhere&lt;/div&gt;
             * Register a callback on a specific socket event
             *
             * @method on
             * @param name {String}
             * @param callback {Function}
             * @example
             * Register a callback for &#x60;message&#x60; event
             *
             *      Bridge.Socket.on(&#x27;message&#x27;, function (data) {
             *          console.log(data);
             *      });
             */
            on: function (name, callback) {
                on(name, callback);
            },
            /**
             * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Anywhere&lt;/div&gt;
             * Emit a new message to server/client
             *
             * @method emit
             * @param name {String}
             * @param data {Object}
             * @param id {String} &lt;span class=&quot;important-info&quot;&gt;Only available on server&lt;/span&gt;
             * @example
             * Emit a &#x60;message&#x60; event
             *
             *      Bridge.Socket.emit(&#x27;message&#x27;, {
             *          user: &#x27;username&#x27;,
             *          message: &#x27;message content&#x27;
             *      });
             */
            emit: function (name, data, id) {
                emit(name, data, id);
            },
            /**
             * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Server&lt;/div&gt;
             * Broadcast a new message to all clients
             *
             * @method broadcast
             * @param name {String}
             * @param data {Object}
             * @example
             * Broadcast a &#x60;message&#x60; to all clients
             *
             *      Bridge.Socket.broadcast(&#x27;message&#x27;, {
             *          user: &#x27;username&#x27;,
             *          message: &#x27;message content&#x27;
             *      });
             */
            broadcast: function (name, data) {
                broadcast(name, data);
            },
            /**
             * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Server&lt;/div&gt;
             * Broadcast a new message to all clients provided within the &#x60;ids&#x60; parameter,
             *
             * @method broadcastTo
             * @param name {String}
             * @param data {Object}
             * @param ids {Array}
             * @example
             * Broadcast a &#x60;message&#x60; to some specified clients
             *
             *      Bridge.Socket.broadcastTo(&#x27;message&#x27;, {
             *          user: &#x27;username&#x27;,
             *          message: &#x27;message content&#x27;
             *      }, [
             *          &#x27;c01c1a19-4462-4ecb-d29d-e6944afc3dd3&#x27;,
             *          &#x27;8a109d17-2c0c-422c-d856-ac5b6c8eba00&#x27;,
             *          &#x27;3c0b763e-acb3-4cdd-de00-4f090b9e7326&#x27;
             *      ]);
             */
            broadcastTo: function (name, data, ids) {
                broadcastTo(name, data, ids);
            }
        }
    }());

    /**
     * Accounts provide the build in account system to easily create new users, managing users and complete common
     * required actions on user profiles
     *
     * @class Bridge.Accounts
     */
    Bridge.Accounts = (function () {
        var Accounts = {};
        var createUserCallback = function () {
        };
        var validateNewUserCallback = function () {
            return true;
        };

        if (Bridge.isServer) {
            /**
             * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Server&lt;/div&gt;
             * Validates the creation of a new user account, returns true by default. Specify a callback to perform a
             * specific validation returning true or false.
             *
             * @method validateNewUser
             * @param callback {Function}
             * @example
             * Register a callback to customize the validation of a new user account creation
             *
             *      Bridge.Accounts.validateNewUser(function (user) {
             *          if (usernameIsAvailable(user.username)) {
             *              return true;
             *          }
             *          else {
             *              return false;
             *          }
             *      });
             */
            Accounts.validateNewUser = function (callback) {
                if (typeof callback == &#x27;function&#x27;) {
                    validateNewUserCallback = callback;
                }
            };
            /**
             * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Server&lt;/div&gt;
             * Customize the creation of a new user
             *
             * @method onCreateUser
             * @param callback {Function}
             * @example
             * Register a callback to customize the creation of a new user
             *
             *      Bridge.Accounts.onCreateUser(function (user) {
             *          options.profile.level = 0;      // Customize the profile of a user, by adding new properties
             *          options.picture = &#x27;image.png&#x27;   // Add new properties to the user object
             *      });
             */
            Accounts.onCreateUser = function (callback) {
                if (typeof callback == &#x27;function&#x27;) {
                    createUserCallback = callback;
                }
            };
        }
        else {
            /**
             * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Client&lt;/div&gt;
             * Login a user by providing username and password, if the login fails a single &#x60;Error&#x60; object is passed to
             * the callback function as parameter
             *
             * @method loginWithPassword
             * @param user {String}
             * @param password {String}
             * @param [callback] {Function}
             * @example
             * Login a user
             *
             *      Bridge.Accounts.loginWithPassword(&#x27;username&#x27;, &#x27;password&#x27;, function (Error) {
             *          if (Error) {
             *              console.log(Error.message);
             *          }
             *      });
             */
            Accounts.loginWithPassword = function (user, password, callback) {
                Bridge.Socket.emit(&#x27;loginWithPassword&#x27;, {
                    user: user,
                    password: password
                });
            };
        }
        /**
         * &lt;div class=&quot;usage-box&quot;&gt;&lt;b&gt;USAGE: &lt;/b&gt;Anywhere&lt;/div&gt;
         * Create a new user in the database
         *
         * @method createUser
         * @param user {Object}
         * @param callback {Function} &lt;span class=&quot;important-info&quot;&gt;Only available on server&lt;/span&gt;
         * @example
         * Create a new user
         *
         *      Bridge.Accounts.createUser({
         *          username: &#x27;username&#x27;,
         *          email: &#x27;email@email.com&#x27;,
         *          password: &#x27;password&#x27;,
         *          profile: {
         *              name: &#x27;name&#x27;,
         *              prename: &#x27;prename&#x27;
         *              // Add your own properties you want to store in a users profile
         *          }
         *      });
         */
        Accounts.createUser = function (user, callback) {
            if (Bridge.isServer) {
                if (validateNewUserCallback(user)) {
                    createUserCallback(user);
                    db.collection(&#x27;Users&#x27;).insert(user);
                }
                else {
                    return Bridge.Error(&#x27;The creation of the user was not granted&#x27;);
                }
            }
            else {
                Bridge.Socket.emit(&#x27;createUser&#x27;, user);
            }
        };

        return Accounts;
    }());
    /**
     * Create an Error object by providing the error details as parameter
     *
     * @class Bridge.Error
     * @param message
     * @return {Error}
     * @constructor
     * @example
     * Throw an exception with a localized error message and fallback if the localization package is not included
     *
     *      Bridge.Error(Localization.get(&#x27;Error.notPrivileged&#x27;) || &#x27;You do not have the required permissions to
     *      complete this action&#x27;);
     */
    Bridge.Error = function (message) {
        var Error = function () {
            console.error(message);
            this.message = message;
        };

        return new Error;
    };

    /**
     * Select all matching elements of a collection
     *
     * @method selectElementsFromCollection
     * @param collection {String} Name of the collection to select elements from
     * @param query {Object} Selector to specify the search criteria
     */
    var selectElementsFromCollection = function (collection, query) {
        var result = db[collection];

        if (query) {
            var keys = Object.keys(query);

            for (var key in keys) {
                result = _.filter(result, function (item) {
                    // Ignore $$hashKey field added by underscore.js
                    if (keys[key] == &#x27;$$hashKey&#x27;) {
                        return false;
                    }

                    if (typeof query[keys[key]] == &#x27;object&#x27;) {
                        var innerKey = Object.keys(query[keys[key]])[0];

                        // handle mongodb comparison operators
                        switch (innerKey) {
                            case &#x27;$all&#x27;:
                                break;
                            case &#x27;$gt&#x27;:
                                return item[keys[key]] &gt; query[keys[key]][innerKey];
                                break;
                            case &#x27;$gte&#x27;:
                                return item[keys[key]] &gt;= query[keys[key]][innerKey];
                                break;
                            case &#x27;$in&#x27;:
                                break;
                            case &#x27;$lt&#x27;:
                                return item[keys[key]] &lt; query[keys[key]][innerKey];
                                break;
                            case &#x27;$lte&#x27;:
                                return item[keys[key]] &lt;= query[keys[key]][innerKey];
                                break;
                            case &#x27;$ne&#x27;:
                                // TODO: improve checking &#x27;10&#x27; and 10 return false
                                return (item.hasOwnProperty([keys[key]])) &amp;&amp; (item[keys[key]] != query[keys[key]][innerKey]);
                                break;
                            case &#x27;$nin&#x27;:
                                break;
                            default:
                                break;
                        }
                    }

                    return item[keys[key]] == query[keys[key]];
                });
            }
        }
        return result;
    };

    var init = function () {
        initSocketProtocol();
    };

    /**
     * Initialize socket protocol on client and server
     */
    var initSocketProtocol = function () {
        if (Bridge.isServer) {
            //Listen for client insert messages
            Bridge.Socket.on(&#x27;insert&#x27;, function (data) {
                // store id of client
                var id = this.id;
                // TODO: Check if operation is allowed
                console.log(data.data);
                console.log(db.collection(data.collection));
                db.collection(data.collection).insert(data.data);
                // TODO: Check for changes in subscribed parts of the collections
                for (var collection in publishedCollections[data.collection]) {
                    var result = [];
                    result.push(data.data);
                    var cursor = publishedCollections[data.collection][collection].callback();

                    if (cursor.selector) {
                        var keys = {
                            key: Object.keys(cursor.selector)[0],
                            value: cursor.selector[Object.keys(cursor.selector)[0]]
                        };

                        result = _.filter(result, function (item) {
                            return item[keys.key] == keys.value;
                        });
                    }

                    if (_.isObject(cursor.fields) &amp;&amp; !_.isArray(cursor.fields)) {
                        var fields = cursor.fields;

                        result = _.map(result, function (item) {
                            var obj = {};
                            for (var field in fields) {
                                if (fields[field]) {
                                    if (item.hasOwnProperty(field)) {
                                        obj[field] = item[field];
                                    }
                                }
                            }

                            obj._id = item._id;

                            return obj;
                        });
                    }

                    if (result.length &gt; 0) {
                        var subscribers = publishedCollections[data.collection][collection].subscribers;
                        subscribers = _.filter(subscribers, function (item) {
                            return item != id;
                        });
                        Bridge.Socket.broadcastTo(&#x27;insert&#x27;, {
                            collection: data.collection,
                            data: result[0]
                        }, subscribers);
                    }
                }
            });
            Bridge.Socket.on(&#x27;createUser&#x27;, function (user) {
                var result = Bridge.Accounts.createUser(user);
                Bridge.Socket.emit(&#x27;createUser&#x27;, result, this.id);
            });
            Bridge.Socket.on(&#x27;subscribe&#x27;, function (data) {
                // store id of client
                var id = this.id;

                for (var collection in publishedCollections) {
                    if (publishedCollections[collection].hasOwnProperty(data.name)) {
                        var cursor = publishedCollections[collection][data.name].callback(data.args);

                        cursor.toArray(function (items) {
                            Bridge.Socket.emit(&#x27;publish&#x27;, {
                                name: cursor.collection,
                                data: items
                            }, id);
                        });

                        publishedCollections[collection][data.name].subscribers.push(this.id);
                        return;
                    }
                }

                //Return error if the collection is not published on the server side
                Bridge.Socket.emit(&#x27;publish&#x27;, {
                    Error: &#x27;A collection called &quot;&#x27; + data.name + &#x27;&quot; is not published by the server.&#x27;
                }, id);
            });
            Bridge.Socket.on(&#x27;update&#x27;, function (data) {
                var id = this.id;

                db.collection(data.collection).update(data.query, data.document, data.options);

                /*Bridge.Socket.emit(&#x27;update&#x27;, {
                    collection: name,
                    query: query,
                    document: document,
                    options: options
                });*/

                for (var collection in publishedCollections[data.collection]) {
                    var subscribers = publishedCollections[data.collection][collection].subscribers;
                    subscribers = _.filter(subscribers, function (item) {
                        return item != id;
                    });
                    Bridge.Socket.broadcastTo(&#x27;update&#x27;, {
                        collection: data.collection,
                        query: data.query,
                        document: data.document,
                        options: data.options
                    }, subscribers);
                }
            });
            Bridge.Socket.on(&#x27;remove&#x27;, function (data) {
                var id = this.id;
                db.collection(data.collection).remove(data.data);

                for (var collection in publishedCollections[data.collection]) {
                    var result = [];

                    if (data.data) {
                        result.push(data.data);
                        var cursor = publishedCollections[data.collection][collection].callback();

                        if (cursor.selector) {
                            var keys = {
                                key: Object.keys(cursor.selector)[0],
                                value: cursor.selector[Object.keys(cursor.selector)[0]]
                            };

                            result = _.filter(result, function (item) {
                                return item[keys.key] == keys.value;
                            });
                        }

                        if (_.isObject(cursor.fields) &amp;&amp; !_.isArray(cursor.fields)) {
                            var fields = cursor.fields;

                            result = _.map(result, function (item) {
                                var obj = {};
                                for (var field in fields) {
                                    if (fields[field]) {
                                        if (item.hasOwnProperty(field)) {
                                            obj[field] = item[field];
                                        }
                                    }
                                }

                                obj._id = item._id;

                                return obj;
                            });
                        }
                    }

                    var subscribers = publishedCollections[data.collection][collection].subscribers;
                    subscribers = _.filter(subscribers, function (item) {
                        return item != id;
                    });
                    Bridge.Socket.broadcastTo(&#x27;remove&#x27;, {
                        collection: data.collection,
                        data: data.data
                    }, subscribers);
                }
            });
        }
        else {
            Bridge.ready(function () {
                Bridge.Socket.on(&#x27;insert&#x27;, function (data) {
                    db[data.collection].push(data.data);
                    for (var binding in db[data.collection].bindings) {
                        db[data.collection].bindings[binding].cursor.toArray(function (items) {
                            db[data.collection].bindings[binding].callback(items);
                        });
                    }
                });
                Bridge.Socket.on(&#x27;update&#x27;, function(data) {
                    var results = selectElementsFromCollection(data.collection, data.query);

                    if (results.length &gt; 0) {
                        var tempResults = [{}];

                        var keys = Object.keys(data.document);

                        // TODO: Add multi support, iterate on results array;
                        for (var key in keys) {
                            switch (keys[key]) {
                                case &#x27;$set&#x27;:
                                    var innerKeys = Object.keys(data.document[keys[key]]);

                                    for (var innerKey in innerKeys) {
                                        tempResults[0][innerKeys[innerKey]] = data.document[keys[key]][innerKeys[innerKey]];
                                    }
                                    break;
                                case &#x27;$inc&#x27;:
                                    var innerKeys = Object.keys(keys[key]);

                                    for (var innerKey in innerKeys) {
                                        if (results[0].hasOwnProperty(innerKey)) {
                                            tempResults[0][innerKeys[innerKey]] = results[0][innerKeys[innerKey]] + data.document[keys[key]][innerKeys[innerKey]];
                                        }
                                    }
                                    break;
                                default:

                                    break;
                            }
                        }

                        var items = db[data.collection];

                        for (var item in items) {
                            if (items[item][&#x27;_id&#x27;] == results[0][&#x27;_id&#x27;]) {
                                tempResults[0][&#x27;_id&#x27;] = results[0][&#x27;_id&#x27;];
                                db[data.collection][item] = tempResults[0];
                            }
                        }

                        for (var binding in db[data.collection].bindings) {
                            db[data.collection].bindings[binding].cursor.toArray(function (items) {
                                db[data.collection].bindings[binding].callback(items);
                            });
                        }
                    }
                });
                Bridge.Socket.on(&#x27;remove&#x27;, function (data) {
                    var bindings = db[data.collection].bindings;

                    if (data.data) {
                        var keys = Object.keys(data.data);

                        if (keys.length &lt; 1) {
                            db[data.collection] = [];
                        }
                        else {
                            for (var i = 0; i &lt; db[data.collection].length; i++) {
                                var item = db[data.collection][i];

                                _.each(keys, function (key) {
                                    if (item.hasOwnProperty(key)) {
                                        if (item[key] == data.data[key]) {
                                            db[data.collection].splice(i--, 1);
                                        }
                                    }
                                });
                            }
                        }
                    }
                    else {
                        db[data.collection] = [];
                    }

                    db[data.collection].bindings = bindings;

                    for (var binding in db[data.collection].bindings) {
                        db[data.collection].bindings[binding].cursor.toArray(function (items) {
                            db[data.collection].bindings[binding].callback(items);
                        });
                    }
                });
                Bridge.Socket.on(&#x27;publish&#x27;, function (data) {
                    // check for empty results
                    if (data.hasOwnProperty(&#x27;data&#x27;)) {
                        data.data.forEach(function (item) {
                            if (!db.hasOwnProperty(data.name)) {
                                db[data.name] = [];
                            }

                            if (!_.find(db[data.name], function (element) {
                                return element._id == item._id;
                            })) {
                                db[data.name].push(item);
                            }
                            else {
                                Bridge.Error(&#x27;Element already in local database: _id: &#x27; + item._id);
                            }
                        });
                    }
                    else {
                        if (data.hasOwnProperty(&#x27;Error&#x27;)) {
                            Bridge.Error(data.Error);
                        }
                    }

                    pendingSubscriptions.counter--;

                    if (pendingSubscriptions.counter == 0) {
                        for (var callback in pendingSubscriptions.callbacks) {
                            pendingSubscriptions.callbacks[callback]();
                        }
                    }
                });
                // TODO: add callback
                Bridge.Socket.on(&#x27;loginWithPassword&#x27;, function (data) {

                });
                // TODO: fix callback
                Bridge.Socket.on(&#x27;createUser&#x27;, function (data) {
                    if (typeof callback == &#x27;function&#x27;) {
                        callback(data);
                    }
                });
            })
        }
    };

    init();
}(Bridge, underscore, database, socketio, fs));
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
